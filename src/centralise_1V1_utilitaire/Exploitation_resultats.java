package centralise_1V1_utilitaire;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class Exploitation_resultats {
	public static void main (String args[]) {
		String implem;
		long [] nb_joueurs_SummonerElo0;
		long [] nb_joueurs_Latence0;
		long [] nb_joueurs_Distance0;
		long [] nb_joueurs_Temps0;
		double [] distanceMoyenne;
		long [] temps_moyen;
		long [] temps_tot;
		int nb = 0;
		FileWriter fw = null;
		
		try {
			fw = new FileWriter ("resultats_1V1_centralise");
		} catch (IOException e2) {
			e2.printStackTrace();
		}
		
		for (int i = 0; i < 3; i++) {
			nb_joueurs_SummonerElo0 = new long[10];
			nb_joueurs_Latence0 = new long [10];
			nb_joueurs_Distance0 = new long[10];
			nb_joueurs_Temps0 = new long[10];
			distanceMoyenne = new double[10];
			temps_moyen = new long [10];
			temps_tot = new long [10];
		
			if (i == 0) {
				implem = "random";
			}
			else if (i == 1) {
				implem = "naif";
			}
			else {
				implem = "BD_Spatiale";
			}
			BufferedReader br[] = new BufferedReader[10];
			BufferedReader br1[] = new BufferedReader[10];
			InputStream ips;
			InputStreamReader ipsr; 
			String lu;
			String[] elts;
			for (int j = 0; j < 10; j++) {
				try {
					nb_joueurs_SummonerElo0[j] = 0;
					nb_joueurs_Latence0[j] = 0;
					nb_joueurs_Distance0[j] = 0;
					nb_joueurs_Temps0[j] = 0;
					distanceMoyenne[j] = 0;
					temps_moyen[j] = 0;
					temps_tot[j] = 0;
					
					
					ips = new FileInputStream("statistiques_joueurs_" + implem + (j + 1) + ".csv");
					ipsr = new InputStreamReader(ips);
					br[j] = new BufferedReader(ipsr);
					nb = 0;
					try {
						while ((lu = br[j].readLine()) != null) {
							nb++;
							elts = lu.split(",");
							int summonerElo1 = Integer.parseInt(elts[1]);
							int summonerElo2 = Integer.parseInt(elts[6]);
							int latence1 = Integer.parseInt(elts[2]);
							int latence2 = Integer.parseInt(elts[7]);
							int temps1 = Integer.parseInt(elts[4]);
							int temps2 = Integer.parseInt(elts[9]);
							double distance = 0;
							
							if ((summonerElo1 - summonerElo2) == 0) {
								nb_joueurs_SummonerElo0[j]++;
							}
							if ((latence1 - latence2) == 0) {
								nb_joueurs_Latence0[j]++;
							}
							if ((distance = distance(summonerElo1, latence1, summonerElo2, latence2)) == 0) {
								nb_joueurs_Distance0[j]++;
							}
							if (temps1 == 0) {
								nb_joueurs_Temps0[j]++;
							}
							if (temps2 == 0) {
								nb_joueurs_Temps0[j]++;
							}
							distanceMoyenne[j] += distance;
							temps_moyen[j] = temps_moyen[j] + temps1 + temps2; 
						}
						ips = new FileInputStream("Statistiques_" + implem + "_temps" + (j + 1) + ".csv");
						ipsr = new InputStreamReader(ips);
						br1[j] = new BufferedReader(ipsr);
						
						while ((lu = br1[j].readLine()) != null) {
							temps_tot[j] += Integer.parseInt(lu);
						}
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
										
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
			
			for (int l = 0; l < 10; l++) {
				distanceMoyenne[l] = distanceMoyenne[l] / nb;
				temps_moyen[l] = temps_moyen[l] / (nb * 2);
			}
			
			suppr_min_max_int(nb_joueurs_SummonerElo0);
			suppr_min_max_int (nb_joueurs_Latence0);
			suppr_min_max_int(nb_joueurs_Distance0);
			suppr_min_max_int(nb_joueurs_Temps0);
			suppr_min_max_double(distanceMoyenne);
			suppr_min_max_int(temps_moyen);
			suppr_min_max_int (temps_tot);
			
			try {
				
			
				fw.write("\n\nStatistiques pour l'implémentation " + implem + "\n");
				fw.write("temps total d'éxécution\n");
				fw.flush();
				afficheResInt(temps_tot, fw);
				fw.write("nombre de paires de joueurs matchés ensembles dont l'écart summonerElo = 0\n");
				fw.flush();
				afficheResInt(nb_joueurs_SummonerElo0, fw);
				fw.write("nombre de paires de joueurs matchés ensembles dont l'écart de latence = 0\n");
				fw.flush();
				afficheResInt(nb_joueurs_Latence0, fw);
				fw.write("nombre de paires de joueurs matchés ensembles dont l'écart de distance = 0\n");
				fw.flush();
				afficheResInt(nb_joueurs_Distance0, fw);
				fw.write("nombre de joueurs matchés au bout de 0 secondes\n");
				fw.flush();
				afficheResInt(nb_joueurs_Temps0, fw);
				fw.write("distance moyenne entre les paires de joueurs matchés ensembles\n");
				fw.flush();
				afficheResDouble(distanceMoyenne, fw);
				fw.write("temps moyen de matches des joueurs (en ms)\n");
				fw.flush();
				afficheResInt(temps_moyen, fw);
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
	}
	
	public static double distance (int summonerElo1, int latence1, int summonerElo2, int latence2) {
		return Math.sqrt(Math.pow((summonerElo1 - summonerElo2), 2) + Math.pow((latence1 - latence2), 2));
	}
	
	public static void suppr_min_max_int (long tab[]) {
		long min = Integer.MAX_VALUE;
		long max = Integer.MIN_VALUE;
		int indice_min = 0;
		int indice_max = 0;
		
		for (int i = 0; i < tab.length; i++) {
			if (tab[i] < min) {
				min = tab[i];
				indice_min = i;
			}
			if (tab[i] > max) {
				max = tab[i];
				indice_max = i;
			}
		}
		tab[indice_min] = -1;
		tab[indice_max] = -1;
	}
	
	public static void suppr_min_max_double (double tab[]) {
		double min = Double.MAX_VALUE;
		double max = Double.MIN_VALUE;
		int indice_min = 0;
		int indice_max = 0;
		
		for (int i = 0; i < tab.length; i++) {
			if (tab[i] < min) {
				min = tab[i];
				indice_min = i;
			}
			if (tab[i] > max) {
				max = tab[i];
				indice_max = i;
			}
		}
		tab[indice_min] = -1;
		tab[indice_max] = -1;
	}
	
	
	public static void afficheResInt (long tab[], FileWriter fw) {
		long somme = 0;
		
		try {
			for (int i = 0; i < tab.length; i++) {
				if (tab[i] != -1) {
					fw.write(tab[i] + "\n");
					fw.flush();
					somme += tab[i];
				}
			}
			fw.write("moyenne: " + (somme / (tab.length - 2)) + "\n");
			fw.flush();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public static void afficheResDouble (double tab[], FileWriter fw) {
		double somme = 0;
		
		try {
			for (int i = 0; i < tab.length; i++) {
				if (tab[i] != -1) {
					fw.write(tab[i] + "\n");
					fw.flush();
					somme += tab[i];
				}
			}
			fw.write("moyenne: " + (somme / (tab.length - 2)) + "\n");
			fw.flush();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
















